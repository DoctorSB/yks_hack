{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { extend, isArray, isMap, isIntegerKey, isSymbol, hasOwn, isObject, hasChanged, makeMap, capitalize, toRawType, def, isFunction, NOOP } from '@vue/shared';\nfunction warn(msg, ...args) {\n  console.warn(`[Vue warn] ${msg}`, ...args);\n}\nlet activeEffectScope;\nconst effectScopeStack = [];\nclass EffectScope {\n  constructor(detached = false) {\n    this.active = true;\n    this.effects = [];\n    this.cleanups = [];\n    if (!detached && activeEffectScope) {\n      this.parent = activeEffectScope;\n      this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(this) - 1;\n    }\n  }\n  run(fn) {\n    if (this.active) {\n      try {\n        this.on();\n        return fn();\n      } finally {\n        this.off();\n      }\n    } else if (process.env.NODE_ENV !== 'production') {\n      warn(`cannot run an inactive effect scope.`);\n    }\n  }\n  on() {\n    if (this.active) {\n      effectScopeStack.push(this);\n      activeEffectScope = this;\n    }\n  }\n  off() {\n    if (this.active) {\n      effectScopeStack.pop();\n      activeEffectScope = effectScopeStack[effectScopeStack.length - 1];\n    }\n  }\n  stop(fromParent) {\n    if (this.active) {\n      this.effects.forEach(e => e.stop());\n      this.cleanups.forEach(cleanup => cleanup());\n      if (this.scopes) {\n        this.scopes.forEach(e => e.stop(true));\n      }\n      // nested scope, dereference from parent to avoid memory leaks\n      if (this.parent && !fromParent) {\n        // optimized O(1) removal\n        const last = this.parent.scopes.pop();\n        if (last && last !== this) {\n          this.parent.scopes[this.index] = last;\n          last.index = this.index;\n        }\n      }\n      this.active = false;\n    }\n  }\n}\nfunction effectScope(detached) {\n  return new EffectScope(detached);\n}\nfunction recordEffectScope(effect, scope) {\n  scope = scope || activeEffectScope;\n  if (scope && scope.active) {\n    scope.effects.push(effect);\n  }\n}\nfunction getCurrentScope() {\n  return activeEffectScope;\n}\nfunction onScopeDispose(fn) {\n  if (activeEffectScope) {\n    activeEffectScope.cleanups.push(fn);\n  } else if (process.env.NODE_ENV !== 'production') {\n    warn(`onScopeDispose() is called when there is no active effect scope` + ` to be associated with.`);\n  }\n}\nconst createDep = effects => {\n  const dep = new Set(effects);\n  dep.w = 0;\n  dep.n = 0;\n  return dep;\n};\nconst wasTracked = dep => (dep.w & trackOpBit) > 0;\nconst newTracked = dep => (dep.n & trackOpBit) > 0;\nconst initDepMarkers = ({\n  deps\n}) => {\n  if (deps.length) {\n    for (let i = 0; i < deps.length; i++) {\n      deps[i].w |= trackOpBit; // set was tracked\n    }\n  }\n};\nconst finalizeDepMarkers = effect => {\n  const {\n    deps\n  } = effect;\n  if (deps.length) {\n    let ptr = 0;\n    for (let i = 0; i < deps.length; i++) {\n      const dep = deps[i];\n      if (wasTracked(dep) && !newTracked(dep)) {\n        dep.delete(effect);\n      } else {\n        deps[ptr++] = dep;\n      }\n      // clear bits\n      dep.w &= ~trackOpBit;\n      dep.n &= ~trackOpBit;\n    }\n    deps.length = ptr;\n  }\n};\nconst targetMap = new WeakMap();\n// The number of effects currently being tracked recursively.\nlet effectTrackDepth = 0;\nlet trackOpBit = 1;\n/**\r\n * The bitwise track markers support at most 30 levels of recursion.\r\n * This value is chosen to enable modern JS engines to use a SMI on all platforms.\r\n * When recursion depth is greater, fall back to using a full cleanup.\r\n */\nconst maxMarkerBits = 30;\nconst effectStack = [];\nlet activeEffect;\nconst ITERATE_KEY = Symbol(process.env.NODE_ENV !== 'production' ? 'iterate' : '');\nconst MAP_KEY_ITERATE_KEY = Symbol(process.env.NODE_ENV !== 'production' ? 'Map key iterate' : '');\nclass ReactiveEffect {\n  constructor(fn, scheduler = null, scope) {\n    this.fn = fn;\n    this.scheduler = scheduler;\n    this.active = true;\n    this.deps = [];\n    recordEffectScope(this, scope);\n  }\n  run() {\n    if (!this.active) {\n      return this.fn();\n    }\n    if (!effectStack.includes(this)) {\n      try {\n        effectStack.push(activeEffect = this);\n        enableTracking();\n        trackOpBit = 1 << ++effectTrackDepth;\n        if (effectTrackDepth <= maxMarkerBits) {\n          initDepMarkers(this);\n        } else {\n          cleanupEffect(this);\n        }\n        return this.fn();\n      } finally {\n        if (effectTrackDepth <= maxMarkerBits) {\n          finalizeDepMarkers(this);\n        }\n        trackOpBit = 1 << --effectTrackDepth;\n        resetTracking();\n        effectStack.pop();\n        const n = effectStack.length;\n        activeEffect = n > 0 ? effectStack[n - 1] : undefined;\n      }\n    }\n  }\n  stop() {\n    if (this.active) {\n      cleanupEffect(this);\n      if (this.onStop) {\n        this.onStop();\n      }\n      this.active = false;\n    }\n  }\n}\nfunction cleanupEffect(effect) {\n  const {\n    deps\n  } = effect;\n  if (deps.length) {\n    for (let i = 0; i < deps.length; i++) {\n      deps[i].delete(effect);\n    }\n    deps.length = 0;\n  }\n}\nfunction effect(fn, options) {\n  if (fn.effect) {\n    fn = fn.effect.fn;\n  }\n  const _effect = new ReactiveEffect(fn);\n  if (options) {\n    extend(_effect, options);\n    if (options.scope) recordEffectScope(_effect, options.scope);\n  }\n  if (!options || !options.lazy) {\n    _effect.run();\n  }\n  const runner = _effect.run.bind(_effect);\n  runner.effect = _effect;\n  return runner;\n}\nfunction stop(runner) {\n  runner.effect.stop();\n}\nlet shouldTrack = true;\nconst trackStack = [];\nfunction pauseTracking() {\n  trackStack.push(shouldTrack);\n  shouldTrack = false;\n}\nfunction enableTracking() {\n  trackStack.push(shouldTrack);\n  shouldTrack = true;\n}\nfunction resetTracking() {\n  const last = trackStack.pop();\n  shouldTrack = last === undefined ? true : last;\n}\nfunction track(target, type, key) {\n  if (!isTracking()) {\n    return;\n  }\n  let depsMap = targetMap.get(target);\n  if (!depsMap) {\n    targetMap.set(target, depsMap = new Map());\n  }\n  let dep = depsMap.get(key);\n  if (!dep) {\n    depsMap.set(key, dep = createDep());\n  }\n  const eventInfo = process.env.NODE_ENV !== 'production' ? {\n    effect: activeEffect,\n    target,\n    type,\n    key\n  } : undefined;\n  trackEffects(dep, eventInfo);\n}\nfunction isTracking() {\n  return shouldTrack && activeEffect !== undefined;\n}\nfunction trackEffects(dep, debuggerEventExtraInfo) {\n  let shouldTrack = false;\n  if (effectTrackDepth <= maxMarkerBits) {\n    if (!newTracked(dep)) {\n      dep.n |= trackOpBit; // set newly tracked\n      shouldTrack = !wasTracked(dep);\n    }\n  } else {\n    // Full cleanup mode.\n    shouldTrack = !dep.has(activeEffect);\n  }\n  if (shouldTrack) {\n    dep.add(activeEffect);\n    activeEffect.deps.push(dep);\n    if (process.env.NODE_ENV !== 'production' && activeEffect.onTrack) {\n      activeEffect.onTrack(Object.assign({\n        effect: activeEffect\n      }, debuggerEventExtraInfo));\n    }\n  }\n}\nfunction trigger(target, type, key, newValue, oldValue, oldTarget) {\n  const depsMap = targetMap.get(target);\n  if (!depsMap) {\n    // never been tracked\n    return;\n  }\n  let deps = [];\n  if (type === \"clear\" /* CLEAR */) {\n    // collection being cleared\n    // trigger all effects for target\n    deps = [...depsMap.values()];\n  } else if (key === 'length' && isArray(target)) {\n    depsMap.forEach((dep, key) => {\n      if (key === 'length' || key >= newValue) {\n        deps.push(dep);\n      }\n    });\n  } else {\n    // schedule runs for SET | ADD | DELETE\n    if (key !== void 0) {\n      deps.push(depsMap.get(key));\n    }\n    // also run for iteration key on ADD | DELETE | Map.SET\n    switch (type) {\n      case \"add\" /* ADD */:\n        if (!isArray(target)) {\n          deps.push(depsMap.get(ITERATE_KEY));\n          if (isMap(target)) {\n            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));\n          }\n        } else if (isIntegerKey(key)) {\n          // new index added to array -> length changes\n          deps.push(depsMap.get('length'));\n        }\n        break;\n      case \"delete\" /* DELETE */:\n        if (!isArray(target)) {\n          deps.push(depsMap.get(ITERATE_KEY));\n          if (isMap(target)) {\n            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));\n          }\n        }\n        break;\n      case \"set\" /* SET */:\n        if (isMap(target)) {\n          deps.push(depsMap.get(ITERATE_KEY));\n        }\n        break;\n    }\n  }\n  const eventInfo = process.env.NODE_ENV !== 'production' ? {\n    target,\n    type,\n    key,\n    newValue,\n    oldValue,\n    oldTarget\n  } : undefined;\n  if (deps.length === 1) {\n    if (deps[0]) {\n      if (process.env.NODE_ENV !== 'production') {\n        triggerEffects(deps[0], eventInfo);\n      } else {\n        triggerEffects(deps[0]);\n      }\n    }\n  } else {\n    const effects = [];\n    for (const dep of deps) {\n      if (dep) {\n        effects.push(...dep);\n      }\n    }\n    if (process.env.NODE_ENV !== 'production') {\n      triggerEffects(createDep(effects), eventInfo);\n    } else {\n      triggerEffects(createDep(effects));\n    }\n  }\n}\nfunction triggerEffects(dep, debuggerEventExtraInfo) {\n  // spread into array for stabilization\n  for (const effect of isArray(dep) ? dep : [...dep]) {\n    if (effect !== activeEffect || effect.allowRecurse) {\n      if (process.env.NODE_ENV !== 'production' && effect.onTrigger) {\n        effect.onTrigger(extend({\n          effect\n        }, debuggerEventExtraInfo));\n      }\n      if (effect.scheduler) {\n        effect.scheduler();\n      } else {\n        effect.run();\n      }\n    }\n  }\n}\nconst isNonTrackableKeys = /*#__PURE__*/makeMap(`__proto__,__v_isRef,__isVue`);\nconst builtInSymbols = new Set(Object.getOwnPropertyNames(Symbol).map(key => Symbol[key]).filter(isSymbol));\nconst get = /*#__PURE__*/createGetter();\nconst shallowGet = /*#__PURE__*/createGetter(false, true);\nconst readonlyGet = /*#__PURE__*/createGetter(true);\nconst shallowReadonlyGet = /*#__PURE__*/createGetter(true, true);\nconst arrayInstrumentations = /*#__PURE__*/createArrayInstrumentations();\nfunction createArrayInstrumentations() {\n  const instrumentations = {};\n  ['includes', 'indexOf', 'lastIndexOf'].forEach(key => {\n    instrumentations[key] = function (...args) {\n      const arr = toRaw(this);\n      for (let i = 0, l = this.length; i < l; i++) {\n        track(arr, \"get\" /* GET */, i + '');\n      }\n      // we run the method using the original args first (which may be reactive)\n      const res = arr[key](...args);\n      if (res === -1 || res === false) {\n        // if that didn't work, run it again using raw values.\n        return arr[key](...args.map(toRaw));\n      } else {\n        return res;\n      }\n    };\n  });\n  ['push', 'pop', 'shift', 'unshift', 'splice'].forEach(key => {\n    instrumentations[key] = function (...args) {\n      pauseTracking();\n      const res = toRaw(this)[key].apply(this, args);\n      resetTracking();\n      return res;\n    };\n  });\n  return instrumentations;\n}\nfunction createGetter(isReadonly = false, shallow = false) {\n  return function get(target, key, receiver) {\n    if (key === \"__v_isReactive\" /* IS_REACTIVE */) {\n      return !isReadonly;\n    } else if (key === \"__v_isReadonly\" /* IS_READONLY */) {\n      return isReadonly;\n    } else if (key === \"__v_raw\" /* RAW */ && receiver === (isReadonly ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target)) {\n      return target;\n    }\n    const targetIsArray = isArray(target);\n    if (!isReadonly && targetIsArray && hasOwn(arrayInstrumentations, key)) {\n      return Reflect.get(arrayInstrumentations, key, receiver);\n    }\n    const res = Reflect.get(target, key, receiver);\n    if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {\n      return res;\n    }\n    if (!isReadonly) {\n      track(target, \"get\" /* GET */, key);\n    }\n    if (shallow) {\n      return res;\n    }\n    if (isRef(res)) {\n      // ref unwrapping - does not apply for Array + integer key.\n      const shouldUnwrap = !targetIsArray || !isIntegerKey(key);\n      return shouldUnwrap ? res.value : res;\n    }\n    if (isObject(res)) {\n      // Convert returned value into a proxy as well. we do the isObject check\n      // here to avoid invalid value warning. Also need to lazy access readonly\n      // and reactive here to avoid circular dependency.\n      return isReadonly ? readonly(res) : reactive(res);\n    }\n    return res;\n  };\n}\nconst set = /*#__PURE__*/createSetter();\nconst shallowSet = /*#__PURE__*/createSetter(true);\nfunction createSetter(shallow = false) {\n  return function set(target, key, value, receiver) {\n    let oldValue = target[key];\n    if (!shallow && !isReadonly(value)) {\n      value = toRaw(value);\n      oldValue = toRaw(oldValue);\n      if (!isArray(target) && isRef(oldValue) && !isRef(value)) {\n        oldValue.value = value;\n        return true;\n      }\n    }\n    const hadKey = isArray(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);\n    const result = Reflect.set(target, key, value, receiver);\n    // don't trigger if target is something up in the prototype chain of original\n    if (target === toRaw(receiver)) {\n      if (!hadKey) {\n        trigger(target, \"add\" /* ADD */, key, value);\n      } else if (hasChanged(value, oldValue)) {\n        trigger(target, \"set\" /* SET */, key, value, oldValue);\n      }\n    }\n    return result;\n  };\n}\nfunction deleteProperty(target, key) {\n  const hadKey = hasOwn(target, key);\n  const oldValue = target[key];\n  const result = Reflect.deleteProperty(target, key);\n  if (result && hadKey) {\n    trigger(target, \"delete\" /* DELETE */, key, undefined, oldValue);\n  }\n  return result;\n}\nfunction has(target, key) {\n  const result = Reflect.has(target, key);\n  if (!isSymbol(key) || !builtInSymbols.has(key)) {\n    track(target, \"has\" /* HAS */, key);\n  }\n  return result;\n}\nfunction ownKeys(target) {\n  track(target, \"iterate\" /* ITERATE */, isArray(target) ? 'length' : ITERATE_KEY);\n  return Reflect.ownKeys(target);\n}\nconst mutableHandlers = {\n  get,\n  set,\n  deleteProperty,\n  has,\n  ownKeys\n};\nconst readonlyHandlers = {\n  get: readonlyGet,\n  set(target, key) {\n    if (process.env.NODE_ENV !== 'production') {\n      console.warn(`Set operation on key \"${String(key)}\" failed: target is readonly.`, target);\n    }\n    return true;\n  },\n  deleteProperty(target, key) {\n    if (process.env.NODE_ENV !== 'production') {\n      console.warn(`Delete operation on key \"${String(key)}\" failed: target is readonly.`, target);\n    }\n    return true;\n  }\n};\nconst shallowReactiveHandlers = /*#__PURE__*/extend({}, mutableHandlers, {\n  get: shallowGet,\n  set: shallowSet\n});\n// Props handlers are special in the sense that it should not unwrap top-level\n// refs (in order to allow refs to be explicitly passed down), but should\n// retain the reactivity of the normal readonly object.\nconst shallowReadonlyHandlers = /*#__PURE__*/extend({}, readonlyHandlers, {\n  get: shallowReadonlyGet\n});\nconst toShallow = value => value;\nconst getProto = v => Reflect.getPrototypeOf(v);\nfunction get$1(target, key, isReadonly = false, isShallow = false) {\n  // #1772: readonly(reactive(Map)) should return readonly + reactive version\n  // of the value\n  target = target[\"__v_raw\" /* RAW */];\n  const rawTarget = toRaw(target);\n  const rawKey = toRaw(key);\n  if (key !== rawKey) {\n    !isReadonly && track(rawTarget, \"get\" /* GET */, key);\n  }\n  !isReadonly && track(rawTarget, \"get\" /* GET */, rawKey);\n  const {\n    has\n  } = getProto(rawTarget);\n  const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;\n  if (has.call(rawTarget, key)) {\n    return wrap(target.get(key));\n  } else if (has.call(rawTarget, rawKey)) {\n    return wrap(target.get(rawKey));\n  } else if (target !== rawTarget) {\n    // #3602 readonly(reactive(Map))\n    // ensure that the nested reactive `Map` can do tracking for itself\n    target.get(key);\n  }\n}\nfunction has$1(key, isReadonly = false) {\n  const target = this[\"__v_raw\" /* RAW */];\n  const rawTarget = toRaw(target);\n  const rawKey = toRaw(key);\n  if (key !== rawKey) {\n    !isReadonly && track(rawTarget, \"has\" /* HAS */, key);\n  }\n  !isReadonly && track(rawTarget, \"has\" /* HAS */, rawKey);\n  return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);\n}\nfunction size(target, isReadonly = false) {\n  target = target[\"__v_raw\" /* RAW */];\n  !isReadonly && track(toRaw(target), \"iterate\" /* ITERATE */, ITERATE_KEY);\n  return Reflect.get(target, 'size', target);\n}\nfunction add(value) {\n  value = toRaw(value);\n  const target = toRaw(this);\n  const proto = getProto(target);\n  const hadKey = proto.has.call(target, value);\n  if (!hadKey) {\n    target.add(value);\n    trigger(target, \"add\" /* ADD */, value, value);\n  }\n  return this;\n}\nfunction set$1(key, value) {\n  value = toRaw(value);\n  const target = toRaw(this);\n  const {\n    has,\n    get\n  } = getProto(target);\n  let hadKey = has.call(target, key);\n  if (!hadKey) {\n    key = toRaw(key);\n    hadKey = has.call(target, key);\n  } else if (process.env.NODE_ENV !== 'production') {\n    checkIdentityKeys(target, has, key);\n  }\n  const oldValue = get.call(target, key);\n  target.set(key, value);\n  if (!hadKey) {\n    trigger(target, \"add\" /* ADD */, key, value);\n  } else if (hasChanged(value, oldValue)) {\n    trigger(target, \"set\" /* SET */, key, value, oldValue);\n  }\n  return this;\n}\nfunction deleteEntry(key) {\n  const target = toRaw(this);\n  const {\n    has,\n    get\n  } = getProto(target);\n  let hadKey = has.call(target, key);\n  if (!hadKey) {\n    key = toRaw(key);\n    hadKey = has.call(target, key);\n  } else if (process.env.NODE_ENV !== 'production') {\n    checkIdentityKeys(target, has, key);\n  }\n  const oldValue = get ? get.call(target, key) : undefined;\n  // forward the operation before queueing reactions\n  const result = target.delete(key);\n  if (hadKey) {\n    trigger(target, \"delete\" /* DELETE */, key, undefined, oldValue);\n  }\n  return result;\n}\nfunction clear() {\n  const target = toRaw(this);\n  const hadItems = target.size !== 0;\n  const oldTarget = process.env.NODE_ENV !== 'production' ? isMap(target) ? new Map(target) : new Set(target) : undefined;\n  // forward the operation before queueing reactions\n  const result = target.clear();\n  if (hadItems) {\n    trigger(target, \"clear\" /* CLEAR */, undefined, undefined, oldTarget);\n  }\n  return result;\n}\nfunction createForEach(isReadonly, isShallow) {\n  return function forEach(callback, thisArg) {\n    const observed = this;\n    const target = observed[\"__v_raw\" /* RAW */];\n    const rawTarget = toRaw(target);\n    const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;\n    !isReadonly && track(rawTarget, \"iterate\" /* ITERATE */, ITERATE_KEY);\n    return target.forEach((value, key) => {\n      // important: make sure the callback is\n      // 1. invoked with the reactive map as `this` and 3rd arg\n      // 2. the value received should be a corresponding reactive/readonly.\n      return callback.call(thisArg, wrap(value), wrap(key), observed);\n    });\n  };\n}\nfunction createIterableMethod(method, isReadonly, isShallow) {\n  return function (...args) {\n    const target = this[\"__v_raw\" /* RAW */];\n    const rawTarget = toRaw(target);\n    const targetIsMap = isMap(rawTarget);\n    const isPair = method === 'entries' || method === Symbol.iterator && targetIsMap;\n    const isKeyOnly = method === 'keys' && targetIsMap;\n    const innerIterator = target[method](...args);\n    const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;\n    !isReadonly && track(rawTarget, \"iterate\" /* ITERATE */, isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);\n    // return a wrapped iterator which returns observed versions of the\n    // values emitted from the real iterator\n    return {\n      // iterator protocol\n      next() {\n        const {\n          value,\n          done\n        } = innerIterator.next();\n        return done ? {\n          value,\n          done\n        } : {\n          value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),\n          done\n        };\n      },\n      // iterable protocol\n      [Symbol.iterator]() {\n        return this;\n      }\n    };\n  };\n}\nfunction createReadonlyMethod(type) {\n  return function (...args) {\n    if (process.env.NODE_ENV !== 'production') {\n      const key = args[0] ? `on key \"${args[0]}\" ` : ``;\n      console.warn(`${capitalize(type)} operation ${key}failed: target is readonly.`, toRaw(this));\n    }\n    return type === \"delete\" /* DELETE */ ? false : this;\n  };\n}\nfunction createInstrumentations() {\n  const mutableInstrumentations = {\n    get(key) {\n      return get$1(this, key);\n    },\n    get size() {\n      return size(this);\n    },\n    has: has$1,\n    add,\n    set: set$1,\n    delete: deleteEntry,\n    clear,\n    forEach: createForEach(false, false)\n  };\n  const shallowInstrumentations = {\n    get(key) {\n      return get$1(this, key, false, true);\n    },\n    get size() {\n      return size(this);\n    },\n    has: has$1,\n    add,\n    set: set$1,\n    delete: deleteEntry,\n    clear,\n    forEach: createForEach(false, true)\n  };\n  const readonlyInstrumentations = {\n    get(key) {\n      return get$1(this, key, true);\n    },\n    get size() {\n      return size(this, true);\n    },\n    has(key) {\n      return has$1.call(this, key, true);\n    },\n    add: createReadonlyMethod(\"add\" /* ADD */),\n    set: createReadonlyMethod(\"set\" /* SET */),\n    delete: createReadonlyMethod(\"delete\" /* DELETE */),\n    clear: createReadonlyMethod(\"clear\" /* CLEAR */),\n    forEach: createForEach(true, false)\n  };\n  const shallowReadonlyInstrumentations = {\n    get(key) {\n      return get$1(this, key, true, true);\n    },\n    get size() {\n      return size(this, true);\n    },\n    has(key) {\n      return has$1.call(this, key, true);\n    },\n    add: createReadonlyMethod(\"add\" /* ADD */),\n    set: createReadonlyMethod(\"set\" /* SET */),\n    delete: createReadonlyMethod(\"delete\" /* DELETE */),\n    clear: createReadonlyMethod(\"clear\" /* CLEAR */),\n    forEach: createForEach(true, true)\n  };\n  const iteratorMethods = ['keys', 'values', 'entries', Symbol.iterator];\n  iteratorMethods.forEach(method => {\n    mutableInstrumentations[method] = createIterableMethod(method, false, false);\n    readonlyInstrumentations[method] = createIterableMethod(method, true, false);\n    shallowInstrumentations[method] = createIterableMethod(method, false, true);\n    shallowReadonlyInstrumentations[method] = createIterableMethod(method, true, true);\n  });\n  return [mutableInstrumentations, readonlyInstrumentations, shallowInstrumentations, shallowReadonlyInstrumentations];\n}\nconst [mutableInstrumentations, readonlyInstrumentations, shallowInstrumentations, shallowReadonlyInstrumentations] = /* #__PURE__*/createInstrumentations();\nfunction createInstrumentationGetter(isReadonly, shallow) {\n  const instrumentations = shallow ? isReadonly ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly ? readonlyInstrumentations : mutableInstrumentations;\n  return (target, key, receiver) => {\n    if (key === \"__v_isReactive\" /* IS_REACTIVE */) {\n      return !isReadonly;\n    } else if (key === \"__v_isReadonly\" /* IS_READONLY */) {\n      return isReadonly;\n    } else if (key === \"__v_raw\" /* RAW */) {\n      return target;\n    }\n    return Reflect.get(hasOwn(instrumentations, key) && key in target ? instrumentations : target, key, receiver);\n  };\n}\nconst mutableCollectionHandlers = {\n  get: /*#__PURE__*/createInstrumentationGetter(false, false)\n};\nconst shallowCollectionHandlers = {\n  get: /*#__PURE__*/createInstrumentationGetter(false, true)\n};\nconst readonlyCollectionHandlers = {\n  get: /*#__PURE__*/createInstrumentationGetter(true, false)\n};\nconst shallowReadonlyCollectionHandlers = {\n  get: /*#__PURE__*/createInstrumentationGetter(true, true)\n};\nfunction checkIdentityKeys(target, has, key) {\n  const rawKey = toRaw(key);\n  if (rawKey !== key && has.call(target, rawKey)) {\n    const type = toRawType(target);\n    console.warn(`Reactive ${type} contains both the raw and reactive ` + `versions of the same object${type === `Map` ? ` as keys` : ``}, ` + `which can lead to inconsistencies. ` + `Avoid differentiating between the raw and reactive versions ` + `of an object and only use the reactive version if possible.`);\n  }\n}\nconst reactiveMap = new WeakMap();\nconst shallowReactiveMap = new WeakMap();\nconst readonlyMap = new WeakMap();\nconst shallowReadonlyMap = new WeakMap();\nfunction targetTypeMap(rawType) {\n  switch (rawType) {\n    case 'Object':\n    case 'Array':\n      return 1 /* COMMON */;\n    case 'Map':\n    case 'Set':\n    case 'WeakMap':\n    case 'WeakSet':\n      return 2 /* COLLECTION */;\n    default:\n      return 0 /* INVALID */;\n  }\n}\nfunction getTargetType(value) {\n  return value[\"__v_skip\" /* SKIP */] || !Object.isExtensible(value) ? 0 /* INVALID */ : targetTypeMap(toRawType(value));\n}\nfunction reactive(target) {\n  // if trying to observe a readonly proxy, return the readonly version.\n  if (target && target[\"__v_isReadonly\" /* IS_READONLY */]) {\n    return target;\n  }\n  return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);\n}\n/**\r\n * Return a shallowly-reactive copy of the original object, where only the root\r\n * level properties are reactive. It also does not auto-unwrap refs (even at the\r\n * root level).\r\n */\nfunction shallowReactive(target) {\n  return createReactiveObject(target, false, shallowReactiveHandlers, shallowCollectionHandlers, shallowReactiveMap);\n}\n/**\r\n * Creates a readonly copy of the original object. Note the returned copy is not\r\n * made reactive, but `readonly` can be called on an already reactive object.\r\n */\nfunction readonly(target) {\n  return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);\n}\n/**\r\n * Returns a reactive-copy of the original object, where only the root level\r\n * properties are readonly, and does NOT unwrap refs nor recursively convert\r\n * returned properties.\r\n * This is used for creating the props proxy object for stateful components.\r\n */\nfunction shallowReadonly(target) {\n  return createReactiveObject(target, true, shallowReadonlyHandlers, shallowReadonlyCollectionHandlers, shallowReadonlyMap);\n}\nfunction createReactiveObject(target, isReadonly, baseHandlers, collectionHandlers, proxyMap) {\n  if (!isObject(target)) {\n    if (process.env.NODE_ENV !== 'production') {\n      console.warn(`value cannot be made reactive: ${String(target)}`);\n    }\n    return target;\n  }\n  // target is already a Proxy, return it.\n  // exception: calling readonly() on a reactive object\n  if (target[\"__v_raw\" /* RAW */] && !(isReadonly && target[\"__v_isReactive\" /* IS_REACTIVE */])) {\n    return target;\n  }\n  // target already has corresponding Proxy\n  const existingProxy = proxyMap.get(target);\n  if (existingProxy) {\n    return existingProxy;\n  }\n  // only a whitelist of value types can be observed.\n  const targetType = getTargetType(target);\n  if (targetType === 0 /* INVALID */) {\n    return target;\n  }\n  const proxy = new Proxy(target, targetType === 2 /* COLLECTION */ ? collectionHandlers : baseHandlers);\n  proxyMap.set(target, proxy);\n  return proxy;\n}\nfunction isReactive(value) {\n  if (isReadonly(value)) {\n    return isReactive(value[\"__v_raw\" /* RAW */]);\n  }\n  return !!(value && value[\"__v_isReactive\" /* IS_REACTIVE */]);\n}\nfunction isReadonly(value) {\n  return !!(value && value[\"__v_isReadonly\" /* IS_READONLY */]);\n}\nfunction isProxy(value) {\n  return isReactive(value) || isReadonly(value);\n}\nfunction toRaw(observed) {\n  const raw = observed && observed[\"__v_raw\" /* RAW */];\n  return raw ? toRaw(raw) : observed;\n}\nfunction markRaw(value) {\n  def(value, \"__v_skip\" /* SKIP */, true);\n  return value;\n}\nconst toReactive = value => isObject(value) ? reactive(value) : value;\nconst toReadonly = value => isObject(value) ? readonly(value) : value;\nfunction trackRefValue(ref) {\n  if (isTracking()) {\n    ref = toRaw(ref);\n    if (!ref.dep) {\n      ref.dep = createDep();\n    }\n    if (process.env.NODE_ENV !== 'production') {\n      trackEffects(ref.dep, {\n        target: ref,\n        type: \"get\" /* GET */,\n        key: 'value'\n      });\n    } else {\n      trackEffects(ref.dep);\n    }\n  }\n}\nfunction triggerRefValue(ref, newVal) {\n  ref = toRaw(ref);\n  if (ref.dep) {\n    if (process.env.NODE_ENV !== 'production') {\n      triggerEffects(ref.dep, {\n        target: ref,\n        type: \"set\" /* SET */,\n        key: 'value',\n        newValue: newVal\n      });\n    } else {\n      triggerEffects(ref.dep);\n    }\n  }\n}\nfunction isRef(r) {\n  return Boolean(r && r.__v_isRef === true);\n}\nfunction ref(value) {\n  return createRef(value, false);\n}\nfunction shallowRef(value) {\n  return createRef(value, true);\n}\nfunction createRef(rawValue, shallow) {\n  if (isRef(rawValue)) {\n    return rawValue;\n  }\n  return new RefImpl(rawValue, shallow);\n}\nclass RefImpl {\n  constructor(value, _shallow) {\n    this._shallow = _shallow;\n    this.dep = undefined;\n    this.__v_isRef = true;\n    this._rawValue = _shallow ? value : toRaw(value);\n    this._value = _shallow ? value : toReactive(value);\n  }\n  get value() {\n    trackRefValue(this);\n    return this._value;\n  }\n  set value(newVal) {\n    newVal = this._shallow ? newVal : toRaw(newVal);\n    if (hasChanged(newVal, this._rawValue)) {\n      this._rawValue = newVal;\n      this._value = this._shallow ? newVal : toReactive(newVal);\n      triggerRefValue(this, newVal);\n    }\n  }\n}\nfunction triggerRef(ref) {\n  triggerRefValue(ref, process.env.NODE_ENV !== 'production' ? ref.value : void 0);\n}\nfunction unref(ref) {\n  return isRef(ref) ? ref.value : ref;\n}\nconst shallowUnwrapHandlers = {\n  get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),\n  set: (target, key, value, receiver) => {\n    const oldValue = target[key];\n    if (isRef(oldValue) && !isRef(value)) {\n      oldValue.value = value;\n      return true;\n    } else {\n      return Reflect.set(target, key, value, receiver);\n    }\n  }\n};\nfunction proxyRefs(objectWithRefs) {\n  return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);\n}\nclass CustomRefImpl {\n  constructor(factory) {\n    this.dep = undefined;\n    this.__v_isRef = true;\n    const {\n      get,\n      set\n    } = factory(() => trackRefValue(this), () => triggerRefValue(this));\n    this._get = get;\n    this._set = set;\n  }\n  get value() {\n    return this._get();\n  }\n  set value(newVal) {\n    this._set(newVal);\n  }\n}\nfunction customRef(factory) {\n  return new CustomRefImpl(factory);\n}\nfunction toRefs(object) {\n  if (process.env.NODE_ENV !== 'production' && !isProxy(object)) {\n    console.warn(`toRefs() expects a reactive object but received a plain one.`);\n  }\n  const ret = isArray(object) ? new Array(object.length) : {};\n  for (const key in object) {\n    ret[key] = toRef(object, key);\n  }\n  return ret;\n}\nclass ObjectRefImpl {\n  constructor(_object, _key, _defaultValue) {\n    this._object = _object;\n    this._key = _key;\n    this._defaultValue = _defaultValue;\n    this.__v_isRef = true;\n  }\n  get value() {\n    const val = this._object[this._key];\n    return val === undefined ? this._defaultValue : val;\n  }\n  set value(newVal) {\n    this._object[this._key] = newVal;\n  }\n}\nfunction toRef(object, key, defaultValue) {\n  const val = object[key];\n  return isRef(val) ? val : new ObjectRefImpl(object, key, defaultValue);\n}\nclass ComputedRefImpl {\n  constructor(getter, _setter, isReadonly) {\n    this._setter = _setter;\n    this.dep = undefined;\n    this._dirty = true;\n    this.__v_isRef = true;\n    this.effect = new ReactiveEffect(getter, () => {\n      if (!this._dirty) {\n        this._dirty = true;\n        triggerRefValue(this);\n      }\n    });\n    this[\"__v_isReadonly\" /* IS_READONLY */] = isReadonly;\n  }\n  get value() {\n    // the computed ref may get wrapped by other proxies e.g. readonly() #3376\n    const self = toRaw(this);\n    trackRefValue(self);\n    if (self._dirty) {\n      self._dirty = false;\n      self._value = self.effect.run();\n    }\n    return self._value;\n  }\n  set value(newValue) {\n    this._setter(newValue);\n  }\n}\nfunction computed(getterOrOptions, debugOptions) {\n  let getter;\n  let setter;\n  const onlyGetter = isFunction(getterOrOptions);\n  if (onlyGetter) {\n    getter = getterOrOptions;\n    setter = process.env.NODE_ENV !== 'production' ? () => {\n      console.warn('Write operation failed: computed value is readonly');\n    } : NOOP;\n  } else {\n    getter = getterOrOptions.get;\n    setter = getterOrOptions.set;\n  }\n  const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter);\n  if (process.env.NODE_ENV !== 'production' && debugOptions) {\n    cRef.effect.onTrack = debugOptions.onTrack;\n    cRef.effect.onTrigger = debugOptions.onTrigger;\n  }\n  return cRef;\n}\nvar _a;\nconst tick = Promise.resolve();\nconst queue = [];\nlet queued = false;\nconst scheduler = fn => {\n  queue.push(fn);\n  if (!queued) {\n    queued = true;\n    tick.then(flush);\n  }\n};\nconst flush = () => {\n  for (let i = 0; i < queue.length; i++) {\n    queue[i]();\n  }\n  queue.length = 0;\n  queued = false;\n};\nclass DeferredComputedRefImpl {\n  constructor(getter) {\n    this.dep = undefined;\n    this._dirty = true;\n    this.__v_isRef = true;\n    this[_a] = true;\n    let compareTarget;\n    let hasCompareTarget = false;\n    let scheduled = false;\n    this.effect = new ReactiveEffect(getter, computedTrigger => {\n      if (this.dep) {\n        if (computedTrigger) {\n          compareTarget = this._value;\n          hasCompareTarget = true;\n        } else if (!scheduled) {\n          const valueToCompare = hasCompareTarget ? compareTarget : this._value;\n          scheduled = true;\n          hasCompareTarget = false;\n          scheduler(() => {\n            if (this.effect.active && this._get() !== valueToCompare) {\n              triggerRefValue(this);\n            }\n            scheduled = false;\n          });\n        }\n        // chained upstream computeds are notified synchronously to ensure\n        // value invalidation in case of sync access; normal effects are\n        // deferred to be triggered in scheduler.\n        for (const e of this.dep) {\n          if (e.computed) {\n            e.scheduler(true /* computedTrigger */);\n          }\n        }\n      }\n      this._dirty = true;\n    });\n    this.effect.computed = true;\n  }\n  _get() {\n    if (this._dirty) {\n      this._dirty = false;\n      return this._value = this.effect.run();\n    }\n    return this._value;\n  }\n  get value() {\n    trackRefValue(this);\n    // the computed ref may get wrapped by other proxies e.g. readonly() #3376\n    return toRaw(this)._get();\n  }\n}\n_a = \"__v_isReadonly\" /* IS_READONLY */;\nfunction deferredComputed(getter) {\n  return new DeferredComputedRefImpl(getter);\n}\nexport { EffectScope, ITERATE_KEY, ReactiveEffect, computed, customRef, deferredComputed, effect, effectScope, enableTracking, getCurrentScope, isProxy, isReactive, isReadonly, isRef, markRaw, onScopeDispose, pauseTracking, proxyRefs, reactive, readonly, ref, resetTracking, shallowReactive, shallowReadonly, shallowRef, stop, toRaw, toRef, toRefs, track, trigger, triggerRef, unref };","map":{"version":3,"names":["extend","isArray","isMap","isIntegerKey","isSymbol","hasOwn","isObject","hasChanged","makeMap","capitalize","toRawType","def","isFunction","NOOP","warn","msg","args","console","activeEffectScope","effectScopeStack","EffectScope","constructor","detached","active","effects","cleanups","parent","index","scopes","push","run","fn","on","off","process","env","NODE_ENV","pop","length","stop","fromParent","forEach","e","cleanup","last","effectScope","recordEffectScope","effect","scope","getCurrentScope","onScopeDispose","createDep","dep","Set","w","n","wasTracked","trackOpBit","newTracked","initDepMarkers","deps","i","finalizeDepMarkers","ptr","delete","targetMap","WeakMap","effectTrackDepth","maxMarkerBits","effectStack","activeEffect","ITERATE_KEY","Symbol","MAP_KEY_ITERATE_KEY","ReactiveEffect","scheduler","includes","enableTracking","cleanupEffect","resetTracking","undefined","onStop","options","_effect","lazy","runner","bind","shouldTrack","trackStack","pauseTracking","track","target","type","key","isTracking","depsMap","get","set","Map","eventInfo","trackEffects","debuggerEventExtraInfo","has","add","onTrack","Object","assign","trigger","newValue","oldValue","oldTarget","values","triggerEffects","allowRecurse","onTrigger","isNonTrackableKeys","builtInSymbols","getOwnPropertyNames","map","filter","createGetter","shallowGet","readonlyGet","shallowReadonlyGet","arrayInstrumentations","createArrayInstrumentations","instrumentations","arr","toRaw","l","res","apply","isReadonly","shallow","receiver","shallowReadonlyMap","readonlyMap","shallowReactiveMap","reactiveMap","targetIsArray","Reflect","isRef","shouldUnwrap","value","readonly","reactive","createSetter","shallowSet","hadKey","Number","result","deleteProperty","ownKeys","mutableHandlers","readonlyHandlers","String","shallowReactiveHandlers","shallowReadonlyHandlers","toShallow","getProto","v","getPrototypeOf","get$1","isShallow","rawTarget","rawKey","wrap","toReadonly","toReactive","call","has$1","size","proto","set$1","checkIdentityKeys","deleteEntry","clear","hadItems","createForEach","callback","thisArg","observed","createIterableMethod","method","targetIsMap","isPair","iterator","isKeyOnly","innerIterator","next","done","createReadonlyMethod","createInstrumentations","mutableInstrumentations","shallowInstrumentations","readonlyInstrumentations","shallowReadonlyInstrumentations","iteratorMethods","createInstrumentationGetter","mutableCollectionHandlers","shallowCollectionHandlers","readonlyCollectionHandlers","shallowReadonlyCollectionHandlers","targetTypeMap","rawType","getTargetType","isExtensible","createReactiveObject","shallowReactive","shallowReadonly","baseHandlers","collectionHandlers","proxyMap","existingProxy","targetType","proxy","Proxy","isReactive","isProxy","raw","markRaw","trackRefValue","ref","triggerRefValue","newVal","r","Boolean","__v_isRef","createRef","shallowRef","rawValue","RefImpl","_shallow","_rawValue","_value","triggerRef","unref","shallowUnwrapHandlers","proxyRefs","objectWithRefs","CustomRefImpl","factory","_get","_set","customRef","toRefs","object","ret","Array","toRef","ObjectRefImpl","_object","_key","_defaultValue","val","defaultValue","ComputedRefImpl","getter","_setter","_dirty","self","computed","getterOrOptions","debugOptions","setter","onlyGetter","cRef","_a","tick","Promise","resolve","queue","queued","then","flush","DeferredComputedRefImpl","compareTarget","hasCompareTarget","scheduled","computedTrigger","valueToCompare","deferredComputed"],"sources":["/home/doduohor/vue/node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js"],"sourcesContent":["import { extend, isArray, isMap, isIntegerKey, isSymbol, hasOwn, isObject, hasChanged, makeMap, capitalize, toRawType, def, isFunction, NOOP } from '@vue/shared';\n\nfunction warn(msg, ...args) {\r\n    console.warn(`[Vue warn] ${msg}`, ...args);\r\n}\n\nlet activeEffectScope;\r\nconst effectScopeStack = [];\r\nclass EffectScope {\r\n    constructor(detached = false) {\r\n        this.active = true;\r\n        this.effects = [];\r\n        this.cleanups = [];\r\n        if (!detached && activeEffectScope) {\r\n            this.parent = activeEffectScope;\r\n            this.index =\r\n                (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(this) - 1;\r\n        }\r\n    }\r\n    run(fn) {\r\n        if (this.active) {\r\n            try {\r\n                this.on();\r\n                return fn();\r\n            }\r\n            finally {\r\n                this.off();\r\n            }\r\n        }\r\n        else if ((process.env.NODE_ENV !== 'production')) {\r\n            warn(`cannot run an inactive effect scope.`);\r\n        }\r\n    }\r\n    on() {\r\n        if (this.active) {\r\n            effectScopeStack.push(this);\r\n            activeEffectScope = this;\r\n        }\r\n    }\r\n    off() {\r\n        if (this.active) {\r\n            effectScopeStack.pop();\r\n            activeEffectScope = effectScopeStack[effectScopeStack.length - 1];\r\n        }\r\n    }\r\n    stop(fromParent) {\r\n        if (this.active) {\r\n            this.effects.forEach(e => e.stop());\r\n            this.cleanups.forEach(cleanup => cleanup());\r\n            if (this.scopes) {\r\n                this.scopes.forEach(e => e.stop(true));\r\n            }\r\n            // nested scope, dereference from parent to avoid memory leaks\r\n            if (this.parent && !fromParent) {\r\n                // optimized O(1) removal\r\n                const last = this.parent.scopes.pop();\r\n                if (last && last !== this) {\r\n                    this.parent.scopes[this.index] = last;\r\n                    last.index = this.index;\r\n                }\r\n            }\r\n            this.active = false;\r\n        }\r\n    }\r\n}\r\nfunction effectScope(detached) {\r\n    return new EffectScope(detached);\r\n}\r\nfunction recordEffectScope(effect, scope) {\r\n    scope = scope || activeEffectScope;\r\n    if (scope && scope.active) {\r\n        scope.effects.push(effect);\r\n    }\r\n}\r\nfunction getCurrentScope() {\r\n    return activeEffectScope;\r\n}\r\nfunction onScopeDispose(fn) {\r\n    if (activeEffectScope) {\r\n        activeEffectScope.cleanups.push(fn);\r\n    }\r\n    else if ((process.env.NODE_ENV !== 'production')) {\r\n        warn(`onScopeDispose() is called when there is no active effect scope` +\r\n            ` to be associated with.`);\r\n    }\r\n}\n\nconst createDep = (effects) => {\r\n    const dep = new Set(effects);\r\n    dep.w = 0;\r\n    dep.n = 0;\r\n    return dep;\r\n};\r\nconst wasTracked = (dep) => (dep.w & trackOpBit) > 0;\r\nconst newTracked = (dep) => (dep.n & trackOpBit) > 0;\r\nconst initDepMarkers = ({ deps }) => {\r\n    if (deps.length) {\r\n        for (let i = 0; i < deps.length; i++) {\r\n            deps[i].w |= trackOpBit; // set was tracked\r\n        }\r\n    }\r\n};\r\nconst finalizeDepMarkers = (effect) => {\r\n    const { deps } = effect;\r\n    if (deps.length) {\r\n        let ptr = 0;\r\n        for (let i = 0; i < deps.length; i++) {\r\n            const dep = deps[i];\r\n            if (wasTracked(dep) && !newTracked(dep)) {\r\n                dep.delete(effect);\r\n            }\r\n            else {\r\n                deps[ptr++] = dep;\r\n            }\r\n            // clear bits\r\n            dep.w &= ~trackOpBit;\r\n            dep.n &= ~trackOpBit;\r\n        }\r\n        deps.length = ptr;\r\n    }\r\n};\n\nconst targetMap = new WeakMap();\r\n// The number of effects currently being tracked recursively.\r\nlet effectTrackDepth = 0;\r\nlet trackOpBit = 1;\r\n/**\r\n * The bitwise track markers support at most 30 levels of recursion.\r\n * This value is chosen to enable modern JS engines to use a SMI on all platforms.\r\n * When recursion depth is greater, fall back to using a full cleanup.\r\n */\r\nconst maxMarkerBits = 30;\r\nconst effectStack = [];\r\nlet activeEffect;\r\nconst ITERATE_KEY = Symbol((process.env.NODE_ENV !== 'production') ? 'iterate' : '');\r\nconst MAP_KEY_ITERATE_KEY = Symbol((process.env.NODE_ENV !== 'production') ? 'Map key iterate' : '');\r\nclass ReactiveEffect {\r\n    constructor(fn, scheduler = null, scope) {\r\n        this.fn = fn;\r\n        this.scheduler = scheduler;\r\n        this.active = true;\r\n        this.deps = [];\r\n        recordEffectScope(this, scope);\r\n    }\r\n    run() {\r\n        if (!this.active) {\r\n            return this.fn();\r\n        }\r\n        if (!effectStack.includes(this)) {\r\n            try {\r\n                effectStack.push((activeEffect = this));\r\n                enableTracking();\r\n                trackOpBit = 1 << ++effectTrackDepth;\r\n                if (effectTrackDepth <= maxMarkerBits) {\r\n                    initDepMarkers(this);\r\n                }\r\n                else {\r\n                    cleanupEffect(this);\r\n                }\r\n                return this.fn();\r\n            }\r\n            finally {\r\n                if (effectTrackDepth <= maxMarkerBits) {\r\n                    finalizeDepMarkers(this);\r\n                }\r\n                trackOpBit = 1 << --effectTrackDepth;\r\n                resetTracking();\r\n                effectStack.pop();\r\n                const n = effectStack.length;\r\n                activeEffect = n > 0 ? effectStack[n - 1] : undefined;\r\n            }\r\n        }\r\n    }\r\n    stop() {\r\n        if (this.active) {\r\n            cleanupEffect(this);\r\n            if (this.onStop) {\r\n                this.onStop();\r\n            }\r\n            this.active = false;\r\n        }\r\n    }\r\n}\r\nfunction cleanupEffect(effect) {\r\n    const { deps } = effect;\r\n    if (deps.length) {\r\n        for (let i = 0; i < deps.length; i++) {\r\n            deps[i].delete(effect);\r\n        }\r\n        deps.length = 0;\r\n    }\r\n}\r\nfunction effect(fn, options) {\r\n    if (fn.effect) {\r\n        fn = fn.effect.fn;\r\n    }\r\n    const _effect = new ReactiveEffect(fn);\r\n    if (options) {\r\n        extend(_effect, options);\r\n        if (options.scope)\r\n            recordEffectScope(_effect, options.scope);\r\n    }\r\n    if (!options || !options.lazy) {\r\n        _effect.run();\r\n    }\r\n    const runner = _effect.run.bind(_effect);\r\n    runner.effect = _effect;\r\n    return runner;\r\n}\r\nfunction stop(runner) {\r\n    runner.effect.stop();\r\n}\r\nlet shouldTrack = true;\r\nconst trackStack = [];\r\nfunction pauseTracking() {\r\n    trackStack.push(shouldTrack);\r\n    shouldTrack = false;\r\n}\r\nfunction enableTracking() {\r\n    trackStack.push(shouldTrack);\r\n    shouldTrack = true;\r\n}\r\nfunction resetTracking() {\r\n    const last = trackStack.pop();\r\n    shouldTrack = last === undefined ? true : last;\r\n}\r\nfunction track(target, type, key) {\r\n    if (!isTracking()) {\r\n        return;\r\n    }\r\n    let depsMap = targetMap.get(target);\r\n    if (!depsMap) {\r\n        targetMap.set(target, (depsMap = new Map()));\r\n    }\r\n    let dep = depsMap.get(key);\r\n    if (!dep) {\r\n        depsMap.set(key, (dep = createDep()));\r\n    }\r\n    const eventInfo = (process.env.NODE_ENV !== 'production')\r\n        ? { effect: activeEffect, target, type, key }\r\n        : undefined;\r\n    trackEffects(dep, eventInfo);\r\n}\r\nfunction isTracking() {\r\n    return shouldTrack && activeEffect !== undefined;\r\n}\r\nfunction trackEffects(dep, debuggerEventExtraInfo) {\r\n    let shouldTrack = false;\r\n    if (effectTrackDepth <= maxMarkerBits) {\r\n        if (!newTracked(dep)) {\r\n            dep.n |= trackOpBit; // set newly tracked\r\n            shouldTrack = !wasTracked(dep);\r\n        }\r\n    }\r\n    else {\r\n        // Full cleanup mode.\r\n        shouldTrack = !dep.has(activeEffect);\r\n    }\r\n    if (shouldTrack) {\r\n        dep.add(activeEffect);\r\n        activeEffect.deps.push(dep);\r\n        if ((process.env.NODE_ENV !== 'production') && activeEffect.onTrack) {\r\n            activeEffect.onTrack(Object.assign({\r\n                effect: activeEffect\r\n            }, debuggerEventExtraInfo));\r\n        }\r\n    }\r\n}\r\nfunction trigger(target, type, key, newValue, oldValue, oldTarget) {\r\n    const depsMap = targetMap.get(target);\r\n    if (!depsMap) {\r\n        // never been tracked\r\n        return;\r\n    }\r\n    let deps = [];\r\n    if (type === \"clear\" /* CLEAR */) {\r\n        // collection being cleared\r\n        // trigger all effects for target\r\n        deps = [...depsMap.values()];\r\n    }\r\n    else if (key === 'length' && isArray(target)) {\r\n        depsMap.forEach((dep, key) => {\r\n            if (key === 'length' || key >= newValue) {\r\n                deps.push(dep);\r\n            }\r\n        });\r\n    }\r\n    else {\r\n        // schedule runs for SET | ADD | DELETE\r\n        if (key !== void 0) {\r\n            deps.push(depsMap.get(key));\r\n        }\r\n        // also run for iteration key on ADD | DELETE | Map.SET\r\n        switch (type) {\r\n            case \"add\" /* ADD */:\r\n                if (!isArray(target)) {\r\n                    deps.push(depsMap.get(ITERATE_KEY));\r\n                    if (isMap(target)) {\r\n                        deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));\r\n                    }\r\n                }\r\n                else if (isIntegerKey(key)) {\r\n                    // new index added to array -> length changes\r\n                    deps.push(depsMap.get('length'));\r\n                }\r\n                break;\r\n            case \"delete\" /* DELETE */:\r\n                if (!isArray(target)) {\r\n                    deps.push(depsMap.get(ITERATE_KEY));\r\n                    if (isMap(target)) {\r\n                        deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));\r\n                    }\r\n                }\r\n                break;\r\n            case \"set\" /* SET */:\r\n                if (isMap(target)) {\r\n                    deps.push(depsMap.get(ITERATE_KEY));\r\n                }\r\n                break;\r\n        }\r\n    }\r\n    const eventInfo = (process.env.NODE_ENV !== 'production')\r\n        ? { target, type, key, newValue, oldValue, oldTarget }\r\n        : undefined;\r\n    if (deps.length === 1) {\r\n        if (deps[0]) {\r\n            if ((process.env.NODE_ENV !== 'production')) {\r\n                triggerEffects(deps[0], eventInfo);\r\n            }\r\n            else {\r\n                triggerEffects(deps[0]);\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        const effects = [];\r\n        for (const dep of deps) {\r\n            if (dep) {\r\n                effects.push(...dep);\r\n            }\r\n        }\r\n        if ((process.env.NODE_ENV !== 'production')) {\r\n            triggerEffects(createDep(effects), eventInfo);\r\n        }\r\n        else {\r\n            triggerEffects(createDep(effects));\r\n        }\r\n    }\r\n}\r\nfunction triggerEffects(dep, debuggerEventExtraInfo) {\r\n    // spread into array for stabilization\r\n    for (const effect of isArray(dep) ? dep : [...dep]) {\r\n        if (effect !== activeEffect || effect.allowRecurse) {\r\n            if ((process.env.NODE_ENV !== 'production') && effect.onTrigger) {\r\n                effect.onTrigger(extend({ effect }, debuggerEventExtraInfo));\r\n            }\r\n            if (effect.scheduler) {\r\n                effect.scheduler();\r\n            }\r\n            else {\r\n                effect.run();\r\n            }\r\n        }\r\n    }\r\n}\n\nconst isNonTrackableKeys = /*#__PURE__*/ makeMap(`__proto__,__v_isRef,__isVue`);\r\nconst builtInSymbols = new Set(Object.getOwnPropertyNames(Symbol)\r\n    .map(key => Symbol[key])\r\n    .filter(isSymbol));\r\nconst get = /*#__PURE__*/ createGetter();\r\nconst shallowGet = /*#__PURE__*/ createGetter(false, true);\r\nconst readonlyGet = /*#__PURE__*/ createGetter(true);\r\nconst shallowReadonlyGet = /*#__PURE__*/ createGetter(true, true);\r\nconst arrayInstrumentations = /*#__PURE__*/ createArrayInstrumentations();\r\nfunction createArrayInstrumentations() {\r\n    const instrumentations = {};\r\n    ['includes', 'indexOf', 'lastIndexOf'].forEach(key => {\r\n        instrumentations[key] = function (...args) {\r\n            const arr = toRaw(this);\r\n            for (let i = 0, l = this.length; i < l; i++) {\r\n                track(arr, \"get\" /* GET */, i + '');\r\n            }\r\n            // we run the method using the original args first (which may be reactive)\r\n            const res = arr[key](...args);\r\n            if (res === -1 || res === false) {\r\n                // if that didn't work, run it again using raw values.\r\n                return arr[key](...args.map(toRaw));\r\n            }\r\n            else {\r\n                return res;\r\n            }\r\n        };\r\n    });\r\n    ['push', 'pop', 'shift', 'unshift', 'splice'].forEach(key => {\r\n        instrumentations[key] = function (...args) {\r\n            pauseTracking();\r\n            const res = toRaw(this)[key].apply(this, args);\r\n            resetTracking();\r\n            return res;\r\n        };\r\n    });\r\n    return instrumentations;\r\n}\r\nfunction createGetter(isReadonly = false, shallow = false) {\r\n    return function get(target, key, receiver) {\r\n        if (key === \"__v_isReactive\" /* IS_REACTIVE */) {\r\n            return !isReadonly;\r\n        }\r\n        else if (key === \"__v_isReadonly\" /* IS_READONLY */) {\r\n            return isReadonly;\r\n        }\r\n        else if (key === \"__v_raw\" /* RAW */ &&\r\n            receiver ===\r\n                (isReadonly\r\n                    ? shallow\r\n                        ? shallowReadonlyMap\r\n                        : readonlyMap\r\n                    : shallow\r\n                        ? shallowReactiveMap\r\n                        : reactiveMap).get(target)) {\r\n            return target;\r\n        }\r\n        const targetIsArray = isArray(target);\r\n        if (!isReadonly && targetIsArray && hasOwn(arrayInstrumentations, key)) {\r\n            return Reflect.get(arrayInstrumentations, key, receiver);\r\n        }\r\n        const res = Reflect.get(target, key, receiver);\r\n        if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {\r\n            return res;\r\n        }\r\n        if (!isReadonly) {\r\n            track(target, \"get\" /* GET */, key);\r\n        }\r\n        if (shallow) {\r\n            return res;\r\n        }\r\n        if (isRef(res)) {\r\n            // ref unwrapping - does not apply for Array + integer key.\r\n            const shouldUnwrap = !targetIsArray || !isIntegerKey(key);\r\n            return shouldUnwrap ? res.value : res;\r\n        }\r\n        if (isObject(res)) {\r\n            // Convert returned value into a proxy as well. we do the isObject check\r\n            // here to avoid invalid value warning. Also need to lazy access readonly\r\n            // and reactive here to avoid circular dependency.\r\n            return isReadonly ? readonly(res) : reactive(res);\r\n        }\r\n        return res;\r\n    };\r\n}\r\nconst set = /*#__PURE__*/ createSetter();\r\nconst shallowSet = /*#__PURE__*/ createSetter(true);\r\nfunction createSetter(shallow = false) {\r\n    return function set(target, key, value, receiver) {\r\n        let oldValue = target[key];\r\n        if (!shallow && !isReadonly(value)) {\r\n            value = toRaw(value);\r\n            oldValue = toRaw(oldValue);\r\n            if (!isArray(target) && isRef(oldValue) && !isRef(value)) {\r\n                oldValue.value = value;\r\n                return true;\r\n            }\r\n        }\r\n        const hadKey = isArray(target) && isIntegerKey(key)\r\n            ? Number(key) < target.length\r\n            : hasOwn(target, key);\r\n        const result = Reflect.set(target, key, value, receiver);\r\n        // don't trigger if target is something up in the prototype chain of original\r\n        if (target === toRaw(receiver)) {\r\n            if (!hadKey) {\r\n                trigger(target, \"add\" /* ADD */, key, value);\r\n            }\r\n            else if (hasChanged(value, oldValue)) {\r\n                trigger(target, \"set\" /* SET */, key, value, oldValue);\r\n            }\r\n        }\r\n        return result;\r\n    };\r\n}\r\nfunction deleteProperty(target, key) {\r\n    const hadKey = hasOwn(target, key);\r\n    const oldValue = target[key];\r\n    const result = Reflect.deleteProperty(target, key);\r\n    if (result && hadKey) {\r\n        trigger(target, \"delete\" /* DELETE */, key, undefined, oldValue);\r\n    }\r\n    return result;\r\n}\r\nfunction has(target, key) {\r\n    const result = Reflect.has(target, key);\r\n    if (!isSymbol(key) || !builtInSymbols.has(key)) {\r\n        track(target, \"has\" /* HAS */, key);\r\n    }\r\n    return result;\r\n}\r\nfunction ownKeys(target) {\r\n    track(target, \"iterate\" /* ITERATE */, isArray(target) ? 'length' : ITERATE_KEY);\r\n    return Reflect.ownKeys(target);\r\n}\r\nconst mutableHandlers = {\r\n    get,\r\n    set,\r\n    deleteProperty,\r\n    has,\r\n    ownKeys\r\n};\r\nconst readonlyHandlers = {\r\n    get: readonlyGet,\r\n    set(target, key) {\r\n        if ((process.env.NODE_ENV !== 'production')) {\r\n            console.warn(`Set operation on key \"${String(key)}\" failed: target is readonly.`, target);\r\n        }\r\n        return true;\r\n    },\r\n    deleteProperty(target, key) {\r\n        if ((process.env.NODE_ENV !== 'production')) {\r\n            console.warn(`Delete operation on key \"${String(key)}\" failed: target is readonly.`, target);\r\n        }\r\n        return true;\r\n    }\r\n};\r\nconst shallowReactiveHandlers = /*#__PURE__*/ extend({}, mutableHandlers, {\r\n    get: shallowGet,\r\n    set: shallowSet\r\n});\r\n// Props handlers are special in the sense that it should not unwrap top-level\r\n// refs (in order to allow refs to be explicitly passed down), but should\r\n// retain the reactivity of the normal readonly object.\r\nconst shallowReadonlyHandlers = /*#__PURE__*/ extend({}, readonlyHandlers, {\r\n    get: shallowReadonlyGet\r\n});\n\nconst toShallow = (value) => value;\r\nconst getProto = (v) => Reflect.getPrototypeOf(v);\r\nfunction get$1(target, key, isReadonly = false, isShallow = false) {\r\n    // #1772: readonly(reactive(Map)) should return readonly + reactive version\r\n    // of the value\r\n    target = target[\"__v_raw\" /* RAW */];\r\n    const rawTarget = toRaw(target);\r\n    const rawKey = toRaw(key);\r\n    if (key !== rawKey) {\r\n        !isReadonly && track(rawTarget, \"get\" /* GET */, key);\r\n    }\r\n    !isReadonly && track(rawTarget, \"get\" /* GET */, rawKey);\r\n    const { has } = getProto(rawTarget);\r\n    const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;\r\n    if (has.call(rawTarget, key)) {\r\n        return wrap(target.get(key));\r\n    }\r\n    else if (has.call(rawTarget, rawKey)) {\r\n        return wrap(target.get(rawKey));\r\n    }\r\n    else if (target !== rawTarget) {\r\n        // #3602 readonly(reactive(Map))\r\n        // ensure that the nested reactive `Map` can do tracking for itself\r\n        target.get(key);\r\n    }\r\n}\r\nfunction has$1(key, isReadonly = false) {\r\n    const target = this[\"__v_raw\" /* RAW */];\r\n    const rawTarget = toRaw(target);\r\n    const rawKey = toRaw(key);\r\n    if (key !== rawKey) {\r\n        !isReadonly && track(rawTarget, \"has\" /* HAS */, key);\r\n    }\r\n    !isReadonly && track(rawTarget, \"has\" /* HAS */, rawKey);\r\n    return key === rawKey\r\n        ? target.has(key)\r\n        : target.has(key) || target.has(rawKey);\r\n}\r\nfunction size(target, isReadonly = false) {\r\n    target = target[\"__v_raw\" /* RAW */];\r\n    !isReadonly && track(toRaw(target), \"iterate\" /* ITERATE */, ITERATE_KEY);\r\n    return Reflect.get(target, 'size', target);\r\n}\r\nfunction add(value) {\r\n    value = toRaw(value);\r\n    const target = toRaw(this);\r\n    const proto = getProto(target);\r\n    const hadKey = proto.has.call(target, value);\r\n    if (!hadKey) {\r\n        target.add(value);\r\n        trigger(target, \"add\" /* ADD */, value, value);\r\n    }\r\n    return this;\r\n}\r\nfunction set$1(key, value) {\r\n    value = toRaw(value);\r\n    const target = toRaw(this);\r\n    const { has, get } = getProto(target);\r\n    let hadKey = has.call(target, key);\r\n    if (!hadKey) {\r\n        key = toRaw(key);\r\n        hadKey = has.call(target, key);\r\n    }\r\n    else if ((process.env.NODE_ENV !== 'production')) {\r\n        checkIdentityKeys(target, has, key);\r\n    }\r\n    const oldValue = get.call(target, key);\r\n    target.set(key, value);\r\n    if (!hadKey) {\r\n        trigger(target, \"add\" /* ADD */, key, value);\r\n    }\r\n    else if (hasChanged(value, oldValue)) {\r\n        trigger(target, \"set\" /* SET */, key, value, oldValue);\r\n    }\r\n    return this;\r\n}\r\nfunction deleteEntry(key) {\r\n    const target = toRaw(this);\r\n    const { has, get } = getProto(target);\r\n    let hadKey = has.call(target, key);\r\n    if (!hadKey) {\r\n        key = toRaw(key);\r\n        hadKey = has.call(target, key);\r\n    }\r\n    else if ((process.env.NODE_ENV !== 'production')) {\r\n        checkIdentityKeys(target, has, key);\r\n    }\r\n    const oldValue = get ? get.call(target, key) : undefined;\r\n    // forward the operation before queueing reactions\r\n    const result = target.delete(key);\r\n    if (hadKey) {\r\n        trigger(target, \"delete\" /* DELETE */, key, undefined, oldValue);\r\n    }\r\n    return result;\r\n}\r\nfunction clear() {\r\n    const target = toRaw(this);\r\n    const hadItems = target.size !== 0;\r\n    const oldTarget = (process.env.NODE_ENV !== 'production')\r\n        ? isMap(target)\r\n            ? new Map(target)\r\n            : new Set(target)\r\n        : undefined;\r\n    // forward the operation before queueing reactions\r\n    const result = target.clear();\r\n    if (hadItems) {\r\n        trigger(target, \"clear\" /* CLEAR */, undefined, undefined, oldTarget);\r\n    }\r\n    return result;\r\n}\r\nfunction createForEach(isReadonly, isShallow) {\r\n    return function forEach(callback, thisArg) {\r\n        const observed = this;\r\n        const target = observed[\"__v_raw\" /* RAW */];\r\n        const rawTarget = toRaw(target);\r\n        const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;\r\n        !isReadonly && track(rawTarget, \"iterate\" /* ITERATE */, ITERATE_KEY);\r\n        return target.forEach((value, key) => {\r\n            // important: make sure the callback is\r\n            // 1. invoked with the reactive map as `this` and 3rd arg\r\n            // 2. the value received should be a corresponding reactive/readonly.\r\n            return callback.call(thisArg, wrap(value), wrap(key), observed);\r\n        });\r\n    };\r\n}\r\nfunction createIterableMethod(method, isReadonly, isShallow) {\r\n    return function (...args) {\r\n        const target = this[\"__v_raw\" /* RAW */];\r\n        const rawTarget = toRaw(target);\r\n        const targetIsMap = isMap(rawTarget);\r\n        const isPair = method === 'entries' || (method === Symbol.iterator && targetIsMap);\r\n        const isKeyOnly = method === 'keys' && targetIsMap;\r\n        const innerIterator = target[method](...args);\r\n        const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;\r\n        !isReadonly &&\r\n            track(rawTarget, \"iterate\" /* ITERATE */, isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);\r\n        // return a wrapped iterator which returns observed versions of the\r\n        // values emitted from the real iterator\r\n        return {\r\n            // iterator protocol\r\n            next() {\r\n                const { value, done } = innerIterator.next();\r\n                return done\r\n                    ? { value, done }\r\n                    : {\r\n                        value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),\r\n                        done\r\n                    };\r\n            },\r\n            // iterable protocol\r\n            [Symbol.iterator]() {\r\n                return this;\r\n            }\r\n        };\r\n    };\r\n}\r\nfunction createReadonlyMethod(type) {\r\n    return function (...args) {\r\n        if ((process.env.NODE_ENV !== 'production')) {\r\n            const key = args[0] ? `on key \"${args[0]}\" ` : ``;\r\n            console.warn(`${capitalize(type)} operation ${key}failed: target is readonly.`, toRaw(this));\r\n        }\r\n        return type === \"delete\" /* DELETE */ ? false : this;\r\n    };\r\n}\r\nfunction createInstrumentations() {\r\n    const mutableInstrumentations = {\r\n        get(key) {\r\n            return get$1(this, key);\r\n        },\r\n        get size() {\r\n            return size(this);\r\n        },\r\n        has: has$1,\r\n        add,\r\n        set: set$1,\r\n        delete: deleteEntry,\r\n        clear,\r\n        forEach: createForEach(false, false)\r\n    };\r\n    const shallowInstrumentations = {\r\n        get(key) {\r\n            return get$1(this, key, false, true);\r\n        },\r\n        get size() {\r\n            return size(this);\r\n        },\r\n        has: has$1,\r\n        add,\r\n        set: set$1,\r\n        delete: deleteEntry,\r\n        clear,\r\n        forEach: createForEach(false, true)\r\n    };\r\n    const readonlyInstrumentations = {\r\n        get(key) {\r\n            return get$1(this, key, true);\r\n        },\r\n        get size() {\r\n            return size(this, true);\r\n        },\r\n        has(key) {\r\n            return has$1.call(this, key, true);\r\n        },\r\n        add: createReadonlyMethod(\"add\" /* ADD */),\r\n        set: createReadonlyMethod(\"set\" /* SET */),\r\n        delete: createReadonlyMethod(\"delete\" /* DELETE */),\r\n        clear: createReadonlyMethod(\"clear\" /* CLEAR */),\r\n        forEach: createForEach(true, false)\r\n    };\r\n    const shallowReadonlyInstrumentations = {\r\n        get(key) {\r\n            return get$1(this, key, true, true);\r\n        },\r\n        get size() {\r\n            return size(this, true);\r\n        },\r\n        has(key) {\r\n            return has$1.call(this, key, true);\r\n        },\r\n        add: createReadonlyMethod(\"add\" /* ADD */),\r\n        set: createReadonlyMethod(\"set\" /* SET */),\r\n        delete: createReadonlyMethod(\"delete\" /* DELETE */),\r\n        clear: createReadonlyMethod(\"clear\" /* CLEAR */),\r\n        forEach: createForEach(true, true)\r\n    };\r\n    const iteratorMethods = ['keys', 'values', 'entries', Symbol.iterator];\r\n    iteratorMethods.forEach(method => {\r\n        mutableInstrumentations[method] = createIterableMethod(method, false, false);\r\n        readonlyInstrumentations[method] = createIterableMethod(method, true, false);\r\n        shallowInstrumentations[method] = createIterableMethod(method, false, true);\r\n        shallowReadonlyInstrumentations[method] = createIterableMethod(method, true, true);\r\n    });\r\n    return [\r\n        mutableInstrumentations,\r\n        readonlyInstrumentations,\r\n        shallowInstrumentations,\r\n        shallowReadonlyInstrumentations\r\n    ];\r\n}\r\nconst [mutableInstrumentations, readonlyInstrumentations, shallowInstrumentations, shallowReadonlyInstrumentations] = /* #__PURE__*/ createInstrumentations();\r\nfunction createInstrumentationGetter(isReadonly, shallow) {\r\n    const instrumentations = shallow\r\n        ? isReadonly\r\n            ? shallowReadonlyInstrumentations\r\n            : shallowInstrumentations\r\n        : isReadonly\r\n            ? readonlyInstrumentations\r\n            : mutableInstrumentations;\r\n    return (target, key, receiver) => {\r\n        if (key === \"__v_isReactive\" /* IS_REACTIVE */) {\r\n            return !isReadonly;\r\n        }\r\n        else if (key === \"__v_isReadonly\" /* IS_READONLY */) {\r\n            return isReadonly;\r\n        }\r\n        else if (key === \"__v_raw\" /* RAW */) {\r\n            return target;\r\n        }\r\n        return Reflect.get(hasOwn(instrumentations, key) && key in target\r\n            ? instrumentations\r\n            : target, key, receiver);\r\n    };\r\n}\r\nconst mutableCollectionHandlers = {\r\n    get: /*#__PURE__*/ createInstrumentationGetter(false, false)\r\n};\r\nconst shallowCollectionHandlers = {\r\n    get: /*#__PURE__*/ createInstrumentationGetter(false, true)\r\n};\r\nconst readonlyCollectionHandlers = {\r\n    get: /*#__PURE__*/ createInstrumentationGetter(true, false)\r\n};\r\nconst shallowReadonlyCollectionHandlers = {\r\n    get: /*#__PURE__*/ createInstrumentationGetter(true, true)\r\n};\r\nfunction checkIdentityKeys(target, has, key) {\r\n    const rawKey = toRaw(key);\r\n    if (rawKey !== key && has.call(target, rawKey)) {\r\n        const type = toRawType(target);\r\n        console.warn(`Reactive ${type} contains both the raw and reactive ` +\r\n            `versions of the same object${type === `Map` ? ` as keys` : ``}, ` +\r\n            `which can lead to inconsistencies. ` +\r\n            `Avoid differentiating between the raw and reactive versions ` +\r\n            `of an object and only use the reactive version if possible.`);\r\n    }\r\n}\n\nconst reactiveMap = new WeakMap();\r\nconst shallowReactiveMap = new WeakMap();\r\nconst readonlyMap = new WeakMap();\r\nconst shallowReadonlyMap = new WeakMap();\r\nfunction targetTypeMap(rawType) {\r\n    switch (rawType) {\r\n        case 'Object':\r\n        case 'Array':\r\n            return 1 /* COMMON */;\r\n        case 'Map':\r\n        case 'Set':\r\n        case 'WeakMap':\r\n        case 'WeakSet':\r\n            return 2 /* COLLECTION */;\r\n        default:\r\n            return 0 /* INVALID */;\r\n    }\r\n}\r\nfunction getTargetType(value) {\r\n    return value[\"__v_skip\" /* SKIP */] || !Object.isExtensible(value)\r\n        ? 0 /* INVALID */\r\n        : targetTypeMap(toRawType(value));\r\n}\r\nfunction reactive(target) {\r\n    // if trying to observe a readonly proxy, return the readonly version.\r\n    if (target && target[\"__v_isReadonly\" /* IS_READONLY */]) {\r\n        return target;\r\n    }\r\n    return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);\r\n}\r\n/**\r\n * Return a shallowly-reactive copy of the original object, where only the root\r\n * level properties are reactive. It also does not auto-unwrap refs (even at the\r\n * root level).\r\n */\r\nfunction shallowReactive(target) {\r\n    return createReactiveObject(target, false, shallowReactiveHandlers, shallowCollectionHandlers, shallowReactiveMap);\r\n}\r\n/**\r\n * Creates a readonly copy of the original object. Note the returned copy is not\r\n * made reactive, but `readonly` can be called on an already reactive object.\r\n */\r\nfunction readonly(target) {\r\n    return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);\r\n}\r\n/**\r\n * Returns a reactive-copy of the original object, where only the root level\r\n * properties are readonly, and does NOT unwrap refs nor recursively convert\r\n * returned properties.\r\n * This is used for creating the props proxy object for stateful components.\r\n */\r\nfunction shallowReadonly(target) {\r\n    return createReactiveObject(target, true, shallowReadonlyHandlers, shallowReadonlyCollectionHandlers, shallowReadonlyMap);\r\n}\r\nfunction createReactiveObject(target, isReadonly, baseHandlers, collectionHandlers, proxyMap) {\r\n    if (!isObject(target)) {\r\n        if ((process.env.NODE_ENV !== 'production')) {\r\n            console.warn(`value cannot be made reactive: ${String(target)}`);\r\n        }\r\n        return target;\r\n    }\r\n    // target is already a Proxy, return it.\r\n    // exception: calling readonly() on a reactive object\r\n    if (target[\"__v_raw\" /* RAW */] &&\r\n        !(isReadonly && target[\"__v_isReactive\" /* IS_REACTIVE */])) {\r\n        return target;\r\n    }\r\n    // target already has corresponding Proxy\r\n    const existingProxy = proxyMap.get(target);\r\n    if (existingProxy) {\r\n        return existingProxy;\r\n    }\r\n    // only a whitelist of value types can be observed.\r\n    const targetType = getTargetType(target);\r\n    if (targetType === 0 /* INVALID */) {\r\n        return target;\r\n    }\r\n    const proxy = new Proxy(target, targetType === 2 /* COLLECTION */ ? collectionHandlers : baseHandlers);\r\n    proxyMap.set(target, proxy);\r\n    return proxy;\r\n}\r\nfunction isReactive(value) {\r\n    if (isReadonly(value)) {\r\n        return isReactive(value[\"__v_raw\" /* RAW */]);\r\n    }\r\n    return !!(value && value[\"__v_isReactive\" /* IS_REACTIVE */]);\r\n}\r\nfunction isReadonly(value) {\r\n    return !!(value && value[\"__v_isReadonly\" /* IS_READONLY */]);\r\n}\r\nfunction isProxy(value) {\r\n    return isReactive(value) || isReadonly(value);\r\n}\r\nfunction toRaw(observed) {\r\n    const raw = observed && observed[\"__v_raw\" /* RAW */];\r\n    return raw ? toRaw(raw) : observed;\r\n}\r\nfunction markRaw(value) {\r\n    def(value, \"__v_skip\" /* SKIP */, true);\r\n    return value;\r\n}\r\nconst toReactive = (value) => isObject(value) ? reactive(value) : value;\r\nconst toReadonly = (value) => isObject(value) ? readonly(value) : value;\n\nfunction trackRefValue(ref) {\r\n    if (isTracking()) {\r\n        ref = toRaw(ref);\r\n        if (!ref.dep) {\r\n            ref.dep = createDep();\r\n        }\r\n        if ((process.env.NODE_ENV !== 'production')) {\r\n            trackEffects(ref.dep, {\r\n                target: ref,\r\n                type: \"get\" /* GET */,\r\n                key: 'value'\r\n            });\r\n        }\r\n        else {\r\n            trackEffects(ref.dep);\r\n        }\r\n    }\r\n}\r\nfunction triggerRefValue(ref, newVal) {\r\n    ref = toRaw(ref);\r\n    if (ref.dep) {\r\n        if ((process.env.NODE_ENV !== 'production')) {\r\n            triggerEffects(ref.dep, {\r\n                target: ref,\r\n                type: \"set\" /* SET */,\r\n                key: 'value',\r\n                newValue: newVal\r\n            });\r\n        }\r\n        else {\r\n            triggerEffects(ref.dep);\r\n        }\r\n    }\r\n}\r\nfunction isRef(r) {\r\n    return Boolean(r && r.__v_isRef === true);\r\n}\r\nfunction ref(value) {\r\n    return createRef(value, false);\r\n}\r\nfunction shallowRef(value) {\r\n    return createRef(value, true);\r\n}\r\nfunction createRef(rawValue, shallow) {\r\n    if (isRef(rawValue)) {\r\n        return rawValue;\r\n    }\r\n    return new RefImpl(rawValue, shallow);\r\n}\r\nclass RefImpl {\r\n    constructor(value, _shallow) {\r\n        this._shallow = _shallow;\r\n        this.dep = undefined;\r\n        this.__v_isRef = true;\r\n        this._rawValue = _shallow ? value : toRaw(value);\r\n        this._value = _shallow ? value : toReactive(value);\r\n    }\r\n    get value() {\r\n        trackRefValue(this);\r\n        return this._value;\r\n    }\r\n    set value(newVal) {\r\n        newVal = this._shallow ? newVal : toRaw(newVal);\r\n        if (hasChanged(newVal, this._rawValue)) {\r\n            this._rawValue = newVal;\r\n            this._value = this._shallow ? newVal : toReactive(newVal);\r\n            triggerRefValue(this, newVal);\r\n        }\r\n    }\r\n}\r\nfunction triggerRef(ref) {\r\n    triggerRefValue(ref, (process.env.NODE_ENV !== 'production') ? ref.value : void 0);\r\n}\r\nfunction unref(ref) {\r\n    return isRef(ref) ? ref.value : ref;\r\n}\r\nconst shallowUnwrapHandlers = {\r\n    get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),\r\n    set: (target, key, value, receiver) => {\r\n        const oldValue = target[key];\r\n        if (isRef(oldValue) && !isRef(value)) {\r\n            oldValue.value = value;\r\n            return true;\r\n        }\r\n        else {\r\n            return Reflect.set(target, key, value, receiver);\r\n        }\r\n    }\r\n};\r\nfunction proxyRefs(objectWithRefs) {\r\n    return isReactive(objectWithRefs)\r\n        ? objectWithRefs\r\n        : new Proxy(objectWithRefs, shallowUnwrapHandlers);\r\n}\r\nclass CustomRefImpl {\r\n    constructor(factory) {\r\n        this.dep = undefined;\r\n        this.__v_isRef = true;\r\n        const { get, set } = factory(() => trackRefValue(this), () => triggerRefValue(this));\r\n        this._get = get;\r\n        this._set = set;\r\n    }\r\n    get value() {\r\n        return this._get();\r\n    }\r\n    set value(newVal) {\r\n        this._set(newVal);\r\n    }\r\n}\r\nfunction customRef(factory) {\r\n    return new CustomRefImpl(factory);\r\n}\r\nfunction toRefs(object) {\r\n    if ((process.env.NODE_ENV !== 'production') && !isProxy(object)) {\r\n        console.warn(`toRefs() expects a reactive object but received a plain one.`);\r\n    }\r\n    const ret = isArray(object) ? new Array(object.length) : {};\r\n    for (const key in object) {\r\n        ret[key] = toRef(object, key);\r\n    }\r\n    return ret;\r\n}\r\nclass ObjectRefImpl {\r\n    constructor(_object, _key, _defaultValue) {\r\n        this._object = _object;\r\n        this._key = _key;\r\n        this._defaultValue = _defaultValue;\r\n        this.__v_isRef = true;\r\n    }\r\n    get value() {\r\n        const val = this._object[this._key];\r\n        return val === undefined ? this._defaultValue : val;\r\n    }\r\n    set value(newVal) {\r\n        this._object[this._key] = newVal;\r\n    }\r\n}\r\nfunction toRef(object, key, defaultValue) {\r\n    const val = object[key];\r\n    return isRef(val)\r\n        ? val\r\n        : new ObjectRefImpl(object, key, defaultValue);\r\n}\n\nclass ComputedRefImpl {\r\n    constructor(getter, _setter, isReadonly) {\r\n        this._setter = _setter;\r\n        this.dep = undefined;\r\n        this._dirty = true;\r\n        this.__v_isRef = true;\r\n        this.effect = new ReactiveEffect(getter, () => {\r\n            if (!this._dirty) {\r\n                this._dirty = true;\r\n                triggerRefValue(this);\r\n            }\r\n        });\r\n        this[\"__v_isReadonly\" /* IS_READONLY */] = isReadonly;\r\n    }\r\n    get value() {\r\n        // the computed ref may get wrapped by other proxies e.g. readonly() #3376\r\n        const self = toRaw(this);\r\n        trackRefValue(self);\r\n        if (self._dirty) {\r\n            self._dirty = false;\r\n            self._value = self.effect.run();\r\n        }\r\n        return self._value;\r\n    }\r\n    set value(newValue) {\r\n        this._setter(newValue);\r\n    }\r\n}\r\nfunction computed(getterOrOptions, debugOptions) {\r\n    let getter;\r\n    let setter;\r\n    const onlyGetter = isFunction(getterOrOptions);\r\n    if (onlyGetter) {\r\n        getter = getterOrOptions;\r\n        setter = (process.env.NODE_ENV !== 'production')\r\n            ? () => {\r\n                console.warn('Write operation failed: computed value is readonly');\r\n            }\r\n            : NOOP;\r\n    }\r\n    else {\r\n        getter = getterOrOptions.get;\r\n        setter = getterOrOptions.set;\r\n    }\r\n    const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter);\r\n    if ((process.env.NODE_ENV !== 'production') && debugOptions) {\r\n        cRef.effect.onTrack = debugOptions.onTrack;\r\n        cRef.effect.onTrigger = debugOptions.onTrigger;\r\n    }\r\n    return cRef;\r\n}\n\nvar _a;\r\nconst tick = Promise.resolve();\r\nconst queue = [];\r\nlet queued = false;\r\nconst scheduler = (fn) => {\r\n    queue.push(fn);\r\n    if (!queued) {\r\n        queued = true;\r\n        tick.then(flush);\r\n    }\r\n};\r\nconst flush = () => {\r\n    for (let i = 0; i < queue.length; i++) {\r\n        queue[i]();\r\n    }\r\n    queue.length = 0;\r\n    queued = false;\r\n};\r\nclass DeferredComputedRefImpl {\r\n    constructor(getter) {\r\n        this.dep = undefined;\r\n        this._dirty = true;\r\n        this.__v_isRef = true;\r\n        this[_a] = true;\r\n        let compareTarget;\r\n        let hasCompareTarget = false;\r\n        let scheduled = false;\r\n        this.effect = new ReactiveEffect(getter, (computedTrigger) => {\r\n            if (this.dep) {\r\n                if (computedTrigger) {\r\n                    compareTarget = this._value;\r\n                    hasCompareTarget = true;\r\n                }\r\n                else if (!scheduled) {\r\n                    const valueToCompare = hasCompareTarget ? compareTarget : this._value;\r\n                    scheduled = true;\r\n                    hasCompareTarget = false;\r\n                    scheduler(() => {\r\n                        if (this.effect.active && this._get() !== valueToCompare) {\r\n                            triggerRefValue(this);\r\n                        }\r\n                        scheduled = false;\r\n                    });\r\n                }\r\n                // chained upstream computeds are notified synchronously to ensure\r\n                // value invalidation in case of sync access; normal effects are\r\n                // deferred to be triggered in scheduler.\r\n                for (const e of this.dep) {\r\n                    if (e.computed) {\r\n                        e.scheduler(true /* computedTrigger */);\r\n                    }\r\n                }\r\n            }\r\n            this._dirty = true;\r\n        });\r\n        this.effect.computed = true;\r\n    }\r\n    _get() {\r\n        if (this._dirty) {\r\n            this._dirty = false;\r\n            return (this._value = this.effect.run());\r\n        }\r\n        return this._value;\r\n    }\r\n    get value() {\r\n        trackRefValue(this);\r\n        // the computed ref may get wrapped by other proxies e.g. readonly() #3376\r\n        return toRaw(this)._get();\r\n    }\r\n}\r\n_a = \"__v_isReadonly\" /* IS_READONLY */;\r\nfunction deferredComputed(getter) {\r\n    return new DeferredComputedRefImpl(getter);\r\n}\n\nexport { EffectScope, ITERATE_KEY, ReactiveEffect, computed, customRef, deferredComputed, effect, effectScope, enableTracking, getCurrentScope, isProxy, isReactive, isReadonly, isRef, markRaw, onScopeDispose, pauseTracking, proxyRefs, reactive, readonly, ref, resetTracking, shallowReactive, shallowReadonly, shallowRef, stop, toRaw, toRef, toRefs, track, trigger, triggerRef, unref };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}